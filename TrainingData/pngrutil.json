{
  "png_read_chunk_header": {
    "label": "read", 
    "uint": 1, 
    "params": 1, 
    "int": 1, 
    ".*\\-": 4, 
    "return": 1
  }, 
  "png_handle_gAMA": {
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "out of place"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 3, 
    "return;": 1, 
    ".*\\-": 3, 
    "if (.*)": 4, 
    "return": 0
  }, 
  "png_inflate_read": {
    "if (.* < \\d*)": 1, 
    "if (.* != 0)": 2, 
    "string": [
      "zstream unclaimed"
    ], 
    "if (.* < .*)": 1, 
    "byte": 1, 
    "label": "read", 
    "uint": 1, 
    "params": 7, 
    "int": 1, 
    "if (.* == 0)": 5, 
    "while(.*)": 1, 
    ".*\\-": 15, 
    "if (.*)": 9, 
    "return": 1, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_get_uint_16": {
    "byte": 1, 
    "label": "get", 
    "uint": 1, 
    "params": 1, 
    "int": 1, 
    "return": 1, 
    ".*\\+": 1
  }, 
  "png_read_filter_row": {
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "if (.* < .*)": 1, 
    "byte": 1, 
    "label": "read", 
    "params": 5, 
    "int": 1, 
    "return;": 1, 
    ".*\\-": 2, 
    "if (.*)": 2, 
    "return": 0, 
    ".*\\+": 1
  }, 
  "png_cache_unknown_chunk": {
    "if (.* != 0)": 3, 
    "string": [
      "unknown chunk exceeds memory limits"
    ], 
    "label": "cache", 
    "uint": 1, 
    "params": 2, 
    "int": 1, 
    "malloc(.*)": 3, 
    "if (.* == 0)": 1, 
    ".*\\-": 16, 
    "if (.*)": 6, 
    "return": 1
  }, 
  "png_zlib_inflate": {
    "if (.* != 0)": 1, 
    "if (.* < \\d*)": 1, 
    "string": [
      "invalid window size (libpng)"
    ], 
    "if (.* < .*)": 1, 
    "params": 2, 
    "int": 1, 
    ".*\\-": 6, 
    "if (.*)": 2, 
    "return": 1
  }, 
  "png_handle_sRGB": {
    "void": 1, 
    "string": [
      "missing IHDR", 
      "too many profiles", 
      "invalid", 
      "out of place"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 4, 
    "return;": 1, 
    ".*\\-": 6, 
    "if (.*)": 5, 
    "return": 0
  }, 
  "png_read_filter_row_up": {
    "void": 1, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "return;": 1, 
    "for (.*)": 1, 
    ".*\\-": 1, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 4
  }, 
  "png_read_start_row": {
    "if (.* != 0)": 9, 
    "if (.* < \\d*)": 9, 
    "void": 1, 
    "string": [
      "\\b\\b\\x04\\x04\\x02\\x02\\x01", 
      "", 
      "\\b\\b\\x04\\x04\\x02\\x02\\x01", 
      "Row has too many bytes to allocate in memory"
    ], 
    "if (.* < .*)": 9, 
    "label": "read", 
    "params": 1, 
    ".*\\+ 0x.*": 7, 
    "malloc(.*)": 2, 
    "if (.* == 0)": 5, 
    "memset(.*)": 1, 
    "return;": 1, 
    ".*\\-": 55, 
    "if (.*)": 31, 
    "return": 0, 
    ".*\\+": 13, 
    "= .*\\+": 9
  }, 
  "png_handle_bKGD": {
    "if (.* != 0)": 1, 
    "if (.* < \\d*)": 2, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid index", 
      "invalid gray level", 
      "invalid color", 
      "invalid", 
      "duplicate", 
      "out of place"
    ], 
    "if (.* < .*)": 2, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 7, 
    "return;": 4, 
    ".*\\-": 15, 
    "if (.*)": 13, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 4
  }, 
  "png_handle_cHRM": {
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid values", 
      "duplicate", 
      "invalid", 
      "out of place"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 6, 
    "return;": 1, 
    ".*\\-": 10, 
    "if (.*)": 7, 
    "return": 0
  }, 
  "png_handle_sCAL": {
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "out of memory", 
      "bad width format", 
      "bad height format", 
      "non-positive height", 
      "non-positive width", 
      "invalid unit", 
      "duplicate", 
      "out of place"
    ], 
    "if (.* < .*)": 1, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 8, 
    "return;": 1, 
    ".*\\-": 4, 
    "if (.*)": 11, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 3
  }, 
  "png_handle_IEND": {
    "if (.* != 0)": 1, 
    "void": 1, 
    "string": [
      "out of place", 
      "invalid"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 1, 
    "return;": 1, 
    ".*\\-": 2, 
    "if (.*)": 2, 
    "return": 0
  }, 
  "png_read_filter_row_avg": {
    "void": 1, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "return;": 1, 
    "for (.*)": 2, 
    ".*\\-": 4, 
    "return": 0, 
    ".*\\+": 10, 
    "= .*\\+": 10
  }, 
  "png_read_filter_row_sub": {
    "void": 1, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "return;": 1, 
    "for (.*)": 1, 
    ".*\\-": 3, 
    "return": 0, 
    ".*\\+": 5, 
    "= .*\\+": 5
  }, 
  "png_read_finish_row": {
    "if (.* < \\d*)": 2, 
    "if (.* != 0)": 2, 
    "void": 1, 
    "string": [
      "\\b\\b\\x04\\x04\\x02\\x02\\x01", 
      "", 
      "\\b\\b\\x04\\x04\\x02\\x02\\x01", 
      "\\b\\b\\b\\x04\\x04\\x02\\x02", 
      "", 
      "\\b\\b\\b\\x04\\x04\\x02\\x02"
    ], 
    "if (.* < .*)": 2, 
    "break": 2, 
    "label": "read", 
    "params": 1, 
    "memset(.*)": 1, 
    "return;": 2, 
    "while(.*)": 1, 
    ".*\\-": 17, 
    "if (.*)": 6, 
    "return": 0, 
    ".*\\+": 5, 
    "= .*\\+": 4
  }, 
  "png_read_buffer": {
    "if (.* < \\d*)": 2, 
    "string": [
      "insufficient memory to read chunk", 
      "insufficient memory to read chunk"
    ], 
    "if (.* < .*)": 2, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "int": 1, 
    "malloc(.*)": 1, 
    "if (.* == 0)": 1, 
    "memset(.*)": 1, 
    ".*\\-": 6, 
    "if (.*)": 5, 
    "return": 1
  }, 
  "png_crc_read": {
    "void": 1, 
    "byte": 1, 
    "label": "read", 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "return;": 1, 
    "if (.*)": 1, 
    "return": 0
  }, 
  "png_handle_zTXt": {
    "if (.* != 0)": 4, 
    "if (.* < \\d*)": 3, 
    "void": 1, 
    "string": [
      "no space in chunk cache", 
      "missing IHDR", 
      "out of memory"
    ], 
    "if (.* < .*)": 3, 
    "break": 1, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 2, 
    "return;": 3, 
    "while(.*)": 1, 
    ".*\\-": 10, 
    "if (.*)": 16, 
    "return": 0, 
    ".*\\+": 6, 
    "= .*\\+": 2
  }, 
  "png_inflate_claim": {
    "if (.* != 0)": 1, 
    "string": [
      " using zstream", 
      "1.2.11"
    ], 
    "uint": 1, 
    "params": 2, 
    "int": 1, 
    "if (.* == 0)": 3, 
    ".*\\-": 19, 
    "if (.*)": 6, 
    "return": 1
  }, 
  "png_do_read_interlace": {
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "if (.* < .*)": 1, 
    "byte": 1, 
    "label": "read", 
    "uint": 1, 
    "params": 4, 
    "int": 1, 
    "if (.* == 0)": 3, 
    "return;": 1, 
    "memcpy(.*)": 2, 
    "for (.*)": 8, 
    ".*\\-": 43, 
    "if (.*)": 14, 
    "return": 0, 
    ".*\\+": 39, 
    "= .*\\+": 39
  }, 
  "png_combine_row": {
    "if (.* != 0)": 7, 
    "if (.* < \\d*)": 10, 
    "void": 1, 
    "string": [
      "internal row logic error", 
      "internal row size calculation error", 
      "internal row width error", 
      "invalid user transform pixel depth"
    ], 
    "if (.* < .*)": 10, 
    "break": 4, 
    "byte": 1, 
    "params": 3, 
    ".*\\+ 0x.*": 2, 
    "int": 1, 
    "if (.* == 0)": 8, 
    "return;": 11, 
    "while(.*)": 10, 
    "memcpy(.*)": 2, 
    "for (.*)": 1, 
    ".*\\-": 28, 
    "if (.*)": 41, 
    "return": 0, 
    ".*\\+": 45, 
    "= .*\\+": 45
  }, 
  "png_get_int_32": {
    "if (.* != 0)": 1, 
    "byte": 1, 
    "label": "get", 
    "params": 1, 
    "int": 1, 
    "if (.* == 0)": 1, 
    ".*\\-": 1, 
    "if (.*)": 2, 
    "return": 1, 
    ".*\\+": 2, 
    "= .*\\+": 2
  }, 
  "png_crc_finish": {
    "if (.* < \\d*)": 1, 
    "string": [
      "CRC error", 
      "CRC error"
    ], 
    "if (.* < .*)": 1, 
    "uint": 1, 
    "params": 2, 
    ".*\\+ 0x.*": 3, 
    "int": 1, 
    "if (.* == 0)": 3, 
    "while(.*)": 1, 
    ".*\\-": 1, 
    "if (.*)": 4, 
    "return": 1, 
    ".*\\+": 3, 
    "= .*\\+": 2
  }, 
  "png_handle_pCAL": {
    "if (.* < \\d*)": 3, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "out of memory", 
      "invalid", 
      "invalid parameter count", 
      "unrecognized equation type", 
      "out of memory", 
      "invalid data", 
      "duplicate", 
      "out of place"
    ], 
    "if (.* < .*)": 3, 
    "break": 1, 
    "uint": 1, 
    "params": 3, 
    ".*\\+ 0x.*": 1, 
    "int": 1, 
    "malloc(.*)": 1, 
    "if (.* == 0)": 8, 
    "return;": 2, 
    "while(.*)": 1, 
    "for (.*)": 3, 
    ".*\\-": 6, 
    "if (.*)": 14, 
    "return": 0, 
    ".*\\+": 17, 
    "= .*\\+": 12
  }, 
  "png_check_chunk_name": {
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "string": [
      "invalid chunk type"
    ], 
    "if (.* < .*)": 1, 
    "label": "check", 
    "uint": 1, 
    "params": 2, 
    "int": 1, 
    "return;": 1, 
    "for (.*)": 1, 
    "if (.*)": 1, 
    "return": 0, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_handle_tRNS": {
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "invalid", 
      "invalid with alpha channel", 
      "out of place", 
      "invalid", 
      "duplicate", 
      "out of place"
    ], 
    "if (.* < .*)": 1, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 6, 
    "return;": 6, 
    ".*\\-": 17, 
    "if (.*)": 11, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 4
  }, 
  "png_handle_tIME": {
    "if (.* != 0)": 1, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "duplicate"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 3, 
    "return;": 1, 
    ".*\\-": 4, 
    "if (.*)": 5, 
    "return": 0, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_handle_tEXt": {
    "if (.* != 0)": 3, 
    "void": 1, 
    "string": [
      "no space in chunk cache", 
      "missing IHDR", 
      "out of memory", 
      "Insufficient memory to process text chunk"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 2, 
    "return;": 3, 
    "for (.*)": 1, 
    ".*\\-": 7, 
    "if (.*)": 9, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 4
  }, 
  "png_read_sig": {
    "if (.* < \\d*)": 3, 
    "if (.* != 0)": 2, 
    "void": 1, 
    "string": [
      "Not a PNG file", 
      "PNG file corrupted by ASCII conversion"
    ], 
    "if (.* < .*)": 3, 
    "label": "read", 
    "params": 2, 
    "return;": 1, 
    ".*\\-": 9, 
    "if (.*)": 4, 
    "return": 0, 
    ".*\\+": 3, 
    "= .*\\+": 2
  }, 
  "png_handle_pHYs": {
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "duplicate", 
      "out of place"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 4, 
    "return;": 1, 
    ".*\\-": 3, 
    "if (.*)": 5, 
    "return": 0, 
    ".*\\+": 4
  }, 
  "png_init_filter_functions": {
    "void": 1, 
    "label": "init", 
    "params": 1, 
    "return;": 1, 
    ".*\\-": 6, 
    "if (.*)": 1, 
    "return": 0, 
    ".*\\+": 1
  }, 
  "png_handle_sBIT": {
    "if (.* < \\d*)": 2, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "invalid", 
      "duplicate", 
      "out of place"
    ], 
    "if (.* < .*)": 2, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 6, 
    "return;": 2, 
    "for (.*)": 1, 
    ".*\\-": 16, 
    "if (.*)": 8, 
    "return": 0, 
    ".*\\+": 2, 
    "= .*\\+": 2
  }, 
  "png_read_finish_IDAT": {
    "void": 1, 
    "label": "read", 
    "params": 1, 
    "if (.* == 0)": 2, 
    "return;": 1, 
    ".*\\-": 10, 
    "if (.*)": 3, 
    "return": 0
  }, 
  "png_get_uint_31": {
    "if (.* < \\d*)": 1, 
    "string": [
      "PNG unsigned integer out of range"
    ], 
    "if (.* < .*)": 1, 
    "byte": 1, 
    "label": "get", 
    "uint": 1, 
    "params": 2, 
    "int": 1, 
    "if (.*)": 1, 
    "return": 1, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_get_uint_32": {
    "byte": 1, 
    "label": "get", 
    "uint": 1, 
    "params": 1, 
    "int": 1, 
    "return": 1, 
    ".*\\+": 1
  }, 
  "png_check_chunk_length": {
    "if (.* != 0)": 1, 
    "if (.* < \\d*)": 6, 
    "void": 1, 
    "string": [
      "chunk data is too large"
    ], 
    "if (.* < .*)": 6, 
    "label": "check", 
    "uint": 1, 
    "params": 2, 
    "int": 1, 
    "malloc(.*)": 2, 
    "return;": 1, 
    ".*\\-": 8, 
    "if (.*)": 9, 
    "return": 0, 
    ".*\\+": 2, 
    "= .*\\+": 2
  }, 
  "png_handle_hIST": {
    "if (.* != 0)": 1, 
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "duplicate", 
      "out of place"
    ], 
    "if (.* < .*)": 1, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 4, 
    "return;": 1, 
    "for (.*)": 1, 
    ".*\\-": 3, 
    "if (.*)": 5, 
    "return": 0, 
    ".*\\+": 2, 
    "= .*\\+": 2
  }, 
  "png_crc_error": {
    "label": "error", 
    "params": 1, 
    "int": 1, 
    "if (.* == 0)": 1, 
    ".*\\-": 5, 
    "if (.*)": 2, 
    "return": 1, 
    ".*\\+": 2, 
    "= .*\\+": 1
  }, 
  "png_handle_sPLT": {
    "if (.* != 0)": 1, 
    "if (.* < \\d*)": 2, 
    "void": 1, 
    "string": [
      "No space in chunk cache for sPLT", 
      "missing IHDR", 
      "out of memory", 
      "malformed sPLT chunk", 
      "sPLT chunk too long", 
      "sPLT chunk requires too much memory", 
      "sPLT chunk has bad length", 
      "out of place"
    ], 
    "if (.* < .*)": 2, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "malloc(.*)": 1, 
    "if (.* == 0)": 4, 
    "return;": 3, 
    "for (.*)": 3, 
    ".*\\-": 9, 
    "if (.*)": 13, 
    "return": 0, 
    ".*\\+": 25, 
    "= .*\\+": 18
  }, 
  "png_inflate": {
    "if (.* != 0)": 3, 
    "if (.* < \\d*)": 1, 
    "string": [
      "zstream unclaimed"
    ], 
    "if (.* < .*)": 1, 
    "byte": 1, 
    "uint": 1, 
    "params": 7, 
    "int": 1, 
    "if (.* == 0)": 2, 
    "while(.*)": 1, 
    ".*\\-": 18, 
    "if (.*)": 10, 
    "return": 1, 
    ".*\\+": 4, 
    "= .*\\+": 4
  }, 
  "png_get_fixed_point": {
    "if (.* < \\d*)": 1, 
    "string": [
      "PNG fixed point integer out of range"
    ], 
    "if (.* < .*)": 1, 
    "byte": 1, 
    "label": "get", 
    "params": 2, 
    "int": 1, 
    "if (.*)": 2, 
    "return": 1, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_handle_eXIf": {
    "if (.* < \\d*)": 1, 
    "if (.* != 0)": 1, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "too short", 
      "duplicate", 
      "out of memory", 
      "incorrect byte-order specifier"
    ], 
    "if (.* < .*)": 1, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "malloc(.*)": 1, 
    "if (.* == 0)": 2, 
    "return;": 2, 
    "for (.*)": 1, 
    ".*\\-": 14, 
    "if (.*)": 6, 
    "return": 0, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_handle_unknown": {
    "if (.* != 0)": 2, 
    "if (.* < \\d*)": 3, 
    "void": 1, 
    "string": [
      "error in user chunk", 
      "Saving unknown chunk:", 
      "forcing save of an unhandled chunk; please call png_set_keep_unknown_chunks", 
      "no space in chunk cache", 
      "unhandled critical chunk"
    ], 
    "if (.* < .*)": 3, 
    "uint": 1, 
    "params": 4, 
    "int": 1, 
    "if (.* == 0)": 6, 
    "return;": 1, 
    "goto": 3, 
    ".*\\-": 14, 
    "if (.*)": 15, 
    "return": 0
  }, 
  "png_handle_iCCP": {
    "if (.* < \\d*)": 6, 
    "if (.* != 0)": 5, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "too short", 
      "too short", 
      "extra compressed data", 
      "out of place"
    ], 
    "if (.* < .*)": 6, 
    "break": 1, 
    "uint": 1, 
    "params": 3, 
    ".*\\+ 0x.*": 15, 
    "int": 1, 
    "malloc(.*)": 1, 
    "if (.* == 0)": 13, 
    "return;": 3, 
    "memset(.*)": 1, 
    "while(.*)": 1, 
    "memcpy(.*)": 2, 
    ".*\\-": 24, 
    "if (.*)": 27, 
    "return": 0, 
    ".*\\+": 26, 
    "= .*\\+": 10
  }, 
  "png_handle_iTXt": {
    "if (.* != 0)": 5, 
    "if (.* < \\d*)": 5, 
    "void": 1, 
    "string": [
      "no space in chunk cache", 
      "missing IHDR", 
      "out of memory"
    ], 
    "if (.* < .*)": 5, 
    "break": 3, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 6, 
    "return;": 3, 
    "while(.*)": 3, 
    ".*\\-": 10, 
    "if (.*)": 23, 
    "return": 0, 
    ".*\\+": 19, 
    "= .*\\+": 13
  }, 
  "png_read_filter_row_paeth_multibyte_pixel": {
    "if (.* < \\d*)": 5, 
    "void": 1, 
    "if (.* < .*)": 5, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "return;": 1, 
    "while(.*)": 2, 
    ".*\\-": 10, 
    "if (.*)": 5, 
    "return": 0, 
    ".*\\+": 12, 
    "= .*\\+": 9
  }, 
  "png_handle_PLTE": {
    "if (.* != 0)": 4, 
    "if (.* < \\d*)": 2, 
    "void": 1, 
    "string": [
      "missing IHDR", 
      "duplicate", 
      "ignored in grayscale PNG", 
      "tRNS must be after", 
      "hIST must be after", 
      "bKGD must be after", 
      "invalid", 
      "invalid", 
      "out of place"
    ], 
    "if (.* < .*)": 2, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 3, 
    "return;": 1, 
    "for (.*)": 1, 
    ".*\\-": 15, 
    "if (.*)": 12, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 2
  }, 
  "png_handle_IHDR": {
    "if (.* != 0)": 2, 
    "if (.* < \\d*)": 1, 
    "void": 1, 
    "string": [
      "out of place", 
      "invalid"
    ], 
    "break": 2, 
    "if (.* < .*)": 1, 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "return;": 1, 
    "goto": 2, 
    ".*\\-": 19, 
    "if (.*)": 3, 
    "return": 0, 
    ".*\\+": 4, 
    "= .*\\+": 3, 
    "case": 5
  }, 
  "png_handle_oFFs": {
    "void": 1, 
    "string": [
      "missing IHDR", 
      "invalid", 
      "duplicate", 
      "out of place"
    ], 
    "uint": 1, 
    "params": 3, 
    "int": 1, 
    "if (.* == 0)": 6, 
    "return;": 1, 
    ".*\\-": 5, 
    "if (.*)": 7, 
    "return": 0, 
    ".*\\+": 8, 
    "= .*\\+": 4
  }, 
  "png_read_IDAT_data": {
    "if (.* < \\d*)": 1, 
    "if (.* != 0)": 6, 
    "void": 1, 
    "string": [
      "Not enough image data", 
      "Extra compressed data", 
      "Not enough image data", 
      "Too much image data"
    ], 
    "if (.* < .*)": 1, 
    "break": 1, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "if (.* == 0)": 3, 
    "return;": 2, 
    "while(.*)": 2, 
    ".*\\-": 25, 
    "if (.*)": 13, 
    "return": 0, 
    ".*\\+": 1, 
    "= .*\\+": 1
  }, 
  "png_read_filter_row_paeth_1byte_pixel": {
    "if (.* < \\d*)": 5, 
    "void": 1, 
    "if (.* < .*)": 5, 
    "byte": 1, 
    "label": "read", 
    "params": 3, 
    "return;": 1, 
    "while(.*)": 1, 
    ".*\\-": 6, 
    "if (.*)": 5, 
    "return": 0, 
    ".*\\+": 10, 
    "= .*\\+": 8
  }, 
  "png_decompress_chunk": {
    "if (.* != 0)": 4, 
    "if (.* < \\d*)": 2, 
    "string": [
      "extra compressed data"
    ], 
    "if (.* < .*)": 2, 
    "uint": 1, 
    "params": 5, 
    "int": 1, 
    "malloc(.*)": 3, 
    "if (.* == 0)": 4, 
    "memset(.*)": 1, 
    "memcpy(.*)": 1, 
    ".*\\-": 21, 
    "if (.*)": 15, 
    "return": 1, 
    ".*\\+": 7, 
    "= .*\\+": 4
  }
}